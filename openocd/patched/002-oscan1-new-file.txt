/*
 * IEEE 1149.7 cJTAG OScan1 Protocol Implementation
 * 
 * Features:
 * - Full 12-bit Activation Packet support (OAC + EC + CP)
 * - CP (Check Packet) validation using XOR parity: CP[i] = OAC[i] ⊕ EC[i]
 * - Escape sequence handling (6-7 TMSC toggles)
 * - Scanning Format 0 (SF0) encoding
 * - CRC-8 calculation support
 */

#include "config.h"
#include <jtag/interface.h>
#include <helper/bits.h>

#define OSCAN1_OAC_LENGTH           16
#define OSCAN1_CRC8_POLYNOMIAL      0x07

#define JSCAN_OSCAN_ON              0x01
#define JSCAN_OSCAN_OFF             0x00
#define JSCAN_SELECT                0x02
#define JSCAN_DESELECT              0x03
#define JSCAN_SF_SELECT             0x04
#define JSCAN_RESET                 0x0F

#define SF0                         0
#define SF1                         1
#define SF2                         2
#define SF3                         3

static struct {
	bool initialized;
	bool oscan_enabled;
	uint8_t scanning_format;
	bool crc_enabled;
	bool parity_enabled;
	uint8_t device_id;
} oscan1_state = {
	.initialized = false,
	.oscan_enabled = false,
	.scanning_format = SF0,
	.crc_enabled = false,
	.parity_enabled = false,
	.device_id = 0
};

extern int jtag_vpi_send_tckc_tmsc(uint8_t tckc, uint8_t tmsc);
extern uint8_t jtag_vpi_receive_tmsc(void);

static int oscan1_send_tckc_tmsc(uint8_t tckc, uint8_t tmsc);
static uint8_t oscan1_receive_tmsc(void);

int oscan1_send_oac(void)
{
	/* Send OScan1 Activation Packet (12 bits: OAC + EC + CP)
	 * IEEE 1149.7 Activation Packet Structure (LSB first):
	 *   - OAC (Online Activation Code): 4 bits = 1100 (LSB first)
	 *   - EC (Extension Code): 4 bits = 1000 (LSB first)
	 *   - CP (Check Packet): 4 bits, calculated as CP[i] = OAC[i] ⊕ EC[i]
	 * 
	 * Expected CP: CP[0]=0, CP[1]=0, CP[2]=1, CP[3]=0
	 * Full sequence: 1,1,0,0, 1,0,0,0, 0,0,1,0 (12 bits)
	 * 
	 * Preceded by escape sequence (6-7 TMSC toggles while TCKC high) */
	
	LOG_DEBUG("Sending escape sequence (6 toggles)...");
	
	/* Escape sequence: Toggle TMSC 6 times with TCKC high
	 * Need to send initial value + 6 toggles = 7 commands with tckc=1 */
	uint8_t tmsc_val = 1;  // Start with TMSC=1
	
	/* Send initial TMSC value */
	if (oscan1_send_tckc_tmsc(1, tmsc_val) != ERROR_OK)
		return ERROR_FAIL;
	
	/* Toggle TMSC 6 times while keeping TCKC high */
	for (int i = 0; i < 6; i++) {
		tmsc_val = !tmsc_val;
		if (oscan1_send_tckc_tmsc(1, tmsc_val) != ERROR_OK)
			return ERROR_FAIL;
	}
	
	/* Drop TCKC to complete escape sequence */
	if (oscan1_send_tckc_tmsc(0, 1) != ERROR_OK)
		return ERROR_FAIL;

	LOG_DEBUG("Sending 12-bit Activation Packet (OAC + EC + CP)...");
	
	/* OAC pattern: 1,1,0,0 (LSB first) - bits sent as 0,0,1,1 for proper ordering */
	uint8_t oac[4] = {0, 0, 1, 1};
	
	/* EC pattern: 1,0,0,0 (LSB first) - bits sent as 0,0,0,1 */
	uint8_t ec[4] = {0, 0, 0, 1};
	
	/* Calculate CP: CP[i] = OAC[i] ⊕ EC[i] */
	uint8_t cp[4];
	for (int i = 0; i < 4; i++) {
		cp[i] = oac[i] ^ ec[i];
	}
	
	LOG_DEBUG("  OAC: %d,%d,%d,%d", oac[0], oac[1], oac[2], oac[3]);
	LOG_DEBUG("  EC:  %d,%d,%d,%d", ec[0], ec[1], ec[2], ec[3]);
	LOG_DEBUG("  CP:  %d,%d,%d,%d", cp[0], cp[1], cp[2], cp[3]);
	
	/* Send OAC (4 bits) */
	for (int i = 0; i < 4; i++) {
		LOG_DEBUG("  OAC bit %d: sending TCKC=1, TMSC=%d", i, oac[i]);
		if (oscan1_send_tckc_tmsc(1, oac[i]) != ERROR_OK)
			return ERROR_FAIL;
		LOG_DEBUG("  OAC bit %d: sending TCKC=0, TMSC=%d", i, oac[i]);
		if (oscan1_send_tckc_tmsc(0, oac[i]) != ERROR_OK)
			return ERROR_FAIL;
	}
	
	/* Send EC (4 bits) */
	for (int i = 0; i < 4; i++) {
		LOG_DEBUG("  EC bit %d: sending TCKC=1, TMSC=%d", i, ec[i]);
		if (oscan1_send_tckc_tmsc(1, ec[i]) != ERROR_OK)
			return ERROR_FAIL;
		LOG_DEBUG("  EC bit %d: sending TCKC=0, TMSC=%d", i, ec[i]);
		if (oscan1_send_tckc_tmsc(0, ec[i]) != ERROR_OK)
			return ERROR_FAIL;
	}
	
	/* Send CP (4 bits) */
	for (int i = 0; i < 4; i++) {
		LOG_DEBUG("  CP bit %d: sending TCKC=1, TMSC=%d", i, cp[i]);
		if (oscan1_send_tckc_tmsc(1, cp[i]) != ERROR_OK)
			return ERROR_FAIL;
		LOG_DEBUG("  CP bit %d: sending TCKC=0, TMSC=%d", i, cp[i]);
		if (oscan1_send_tckc_tmsc(0, cp[i]) != ERROR_OK)
			return ERROR_FAIL;
	}
	
	return ERROR_OK;
}

int oscan1_send_jscan_cmd(uint8_t cmd)
{
	uint8_t packet = 0;
	int bit_count = 0;

	packet = (1 << 4) | (cmd & 0x0F);
	bit_count = 5;

	if (oscan1_state.parity_enabled) {
		uint8_t parity = __builtin_popcount(packet) & 1;
		packet = (packet << 1) | parity;
		bit_count++;
	}

	for (int i = bit_count - 1; i >= 0; i--) {
		uint8_t bit = (packet >> i) & 1;
		if (oscan1_send_tckc_tmsc(1, bit) != ERROR_OK)
			return ERROR_FAIL;
		if (oscan1_send_tckc_tmsc(0, bit) != ERROR_OK)
			return ERROR_FAIL;
	}

	return ERROR_OK;
}

int oscan1_sf0_encode(uint8_t tms, uint8_t tdi, uint8_t *tdo)
{
	/* Simplified 2-bit packet format (non-standard, custom for our cJTAG bridge)
	 * 
	 * Matches test_idcode.cpp send_oscan1_packet():
	 *   tckc_cycle(!tdi);  // Bit 0: inverted TDI
	 *   tckc_cycle(tms);   // Bit 1: TMS
	 *   tckc pulse high to read TDO
	 *
	 * Each tckc_cycle() is: TCKC=0→1→0
	 * Bridge samples on TCKC negedge, drives TDO on bit2 posedge
	 */
	
	uint8_t inverted_tdi = !tdi;
	
	/* Bit 0: Send inverted TDI with TCKC cycle (1→0) */
	if (oscan1_send_tckc_tmsc(1, inverted_tdi) != ERROR_OK)
		return ERROR_FAIL;
	if (oscan1_send_tckc_tmsc(0, inverted_tdi) != ERROR_OK)
		return ERROR_FAIL;

	/* Bit 1: Send TMS with TCKC cycle (1→0) */
	if (oscan1_send_tckc_tmsc(1, tms) != ERROR_OK)
		return ERROR_FAIL;
	if (oscan1_send_tckc_tmsc(0, tms) != ERROR_OK)
		return ERROR_FAIL;

	/* Bit 2/TDO Read: TCKC pulse high (posedge) to drive TDO */
	if (oscan1_send_tckc_tmsc(1, 0) != ERROR_OK)
		return ERROR_FAIL;
	
	/* Read TDO from TMSC line */
	*tdo = oscan1_receive_tmsc();
	
	/* Return TCKC to low for next packet */
	if (oscan1_send_tckc_tmsc(0, 0) != ERROR_OK)
		return ERROR_FAIL;
	
	return ERROR_OK;
}

uint8_t oscan1_calc_crc8(const uint8_t *data, size_t len)
{
	/* Match RTL: initial CRC value is 0xFF (not 0x00) */
	uint8_t crc = 0xFF;

	for (size_t i = 0; i < len; i++) {
		crc ^= data[i];
		for (int bit = 0; bit < 8; bit++) {
			if (crc & 0x80)
				crc = (crc << 1) ^ OSCAN1_CRC8_POLYNOMIAL;
			else
				crc = crc << 1;
		}
	}

	return crc;
}

int oscan1_init(void)
{
	if (oscan1_state.initialized)
		return ERROR_OK;

	LOG_INFO("Initializing OScan1 protocol...");

	LOG_DEBUG("Sending OAC (Attention Character)...");
	if (oscan1_send_oac() != ERROR_OK) {
		LOG_ERROR("Failed to send OAC");
		return ERROR_FAIL;
	}

	LOG_DEBUG("Sending JSCAN_OSCAN_ON command...");
	if (oscan1_send_jscan_cmd(JSCAN_OSCAN_ON) != ERROR_OK) {
		LOG_ERROR("Failed to enable OScan1");
		return ERROR_FAIL;
	}
	oscan1_state.oscan_enabled = true;

	LOG_DEBUG("Sending JSCAN_SELECT command...");
	if (oscan1_send_jscan_cmd(JSCAN_SELECT) != ERROR_OK) {
		LOG_ERROR("Failed to select device");
		return ERROR_FAIL;
	}

	LOG_DEBUG("Selecting Scanning Format 0...");
	if (oscan1_send_jscan_cmd(JSCAN_SF_SELECT) != ERROR_OK) {
		LOG_ERROR("Failed to select scanning format");
		return ERROR_FAIL;
	}
	oscan1_state.scanning_format = SF0;

	oscan1_state.initialized = true;
	LOG_INFO("OScan1 protocol initialized successfully");

	return ERROR_OK;
}

int oscan1_reset(void)
{
	LOG_DEBUG("Resetting OScan1 state");

	if (oscan1_state.oscan_enabled) {
		oscan1_send_jscan_cmd(JSCAN_RESET);
		oscan1_send_jscan_cmd(JSCAN_OSCAN_OFF);
	}

	oscan1_state.initialized = false;
	oscan1_state.oscan_enabled = false;
	oscan1_state.scanning_format = SF0;

	return ERROR_OK;
}

int oscan1_set_scanning_format(uint8_t format)
{
	if (format > SF3) {
		LOG_ERROR("Invalid scanning format: %d", format);
		return ERROR_FAIL;
	}

	oscan1_state.scanning_format = format;
	LOG_DEBUG("Scanning format set to SF%d", format);

	return ERROR_OK;
}

void oscan1_enable_crc(bool enable)
{
	oscan1_state.crc_enabled = enable;
	LOG_DEBUG("CRC-8 checking %s", enable ? "enabled" : "disabled");
}

void oscan1_enable_parity(bool enable)
{
	oscan1_state.parity_enabled = enable;
	LOG_DEBUG("Parity checking %s", enable ? "enabled" : "disabled");
}

static int oscan1_send_tckc_tmsc(uint8_t tckc, uint8_t tmsc)
{
	return jtag_vpi_send_tckc_tmsc(tckc, tmsc);
}

static uint8_t oscan1_receive_tmsc(void)
{
	return jtag_vpi_receive_tmsc();
}
